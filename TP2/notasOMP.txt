
#Define o nº de threads na secção paralela
omp_set_num_threads(N);

// Cria uma secção paralela
#pragma omp parallel 
{
    
}

// Declara uma zona crítica, ou seja, uma zona onde não convém estarem várias threads a mexer ao mesmo tempo
#pragma omp critical

Um bloco maior ou mais complexo precisa ser protegido.
Há dependências entre múltiplas variáveis que precisam ser manipuladas juntas.

# pragma omp atomic

A operação é simples (e.g., incrementos, somas).
Está manipulando apenas uma variável compartilhada.

Ambas as instruções acima servem para resolver race conditions. A diferença geral é que o atomic trata de uma única instrução, sendo 
mais recomendado para vigia de acessos a arrays e mais. O critical, por outro lado, faz o mesmo, mas para zonas de código maior, não 
podendo focar tão bem em instruções individuais.

// Cria uma barreira de threads, obrigando todas as threads a parar até todas estarem aqui à espera 
// A maioria de instruções omp já incluem explicitamente barrier no fim da zona btw
#pragma omp barrier 

// Apenas a master thread corre 
#pragma omp master

// Apenas uma thread corre, independente da hierarquia
#pragma omp single 

// Evita false sharing, podendo assim guardar a soma ou qualquer operaçao aritmetica, que vai ser repetida imensas vezes pelas threads 
//diferentes numa variável, deixando a preocupação de race conditions de lado 
#pragma omp reduction(oper:var)

Ex: 

#pragma omp for reduction(+:sum)
    for(int i = 0; i < 100; i++)
        sum += i;